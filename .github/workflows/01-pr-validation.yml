name: PR Validation

on:
  pull_request:
    branches: [main, develop]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  file-count-check:
    name: Check PR File Count
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check file count
        id: file_count
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          FILE_COUNT=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | wc -l)
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "üìä Files changed in this PR: $FILE_COUNT"
          
          # PR„É©„Éô„É´„ÅÆÂèñÂæó
          PR_NUMBER=${{ github.event.pull_request.number }}
          HAS_APPROVAL_LABEL=$(gh pr view $PR_NUMBER --json labels --jq '.labels[].name' | grep -c "large-pr-approved" || echo 0)
          
          if [ $FILE_COUNT -gt 80 ]; then
            echo "‚ö†Ô∏è  WARNING: PR contains $FILE_COUNT files (CodeRabbit recommended limit: 80)"
            
            if [ $HAS_APPROVAL_LABEL -eq 1 ]; then
              echo "‚úÖ 'large-pr-approved' label detected - Exception granted"
              echo "üìù This large PR has been explicitly approved for review"
              exit 0
            else
              echo "‚ùå FAILED: PR exceeds 80 file limit without approval"
              echo ""
              echo "Please either:"
              echo "  1. Split this PR into smaller parts (recommended for better review quality)"
              echo "  2. Add 'large-pr-approved' label if this large PR is necessary"
              echo ""
              echo "CodeRabbit works best with PRs under 80 files for optimal review quality."
              exit 1
            fi
          else
            echo "‚úÖ File count is within limit ($FILE_COUNT/80)"
          fi
      
      - name: Post file count comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fileCount = ${{ steps.file_count.outputs.file_count }};
            const limit = 80;
            const hasApprovalLabel = context.payload.pull_request.labels.some(
              label => label.name === 'large-pr-approved'
            );
            
            let commentBody = `## üìä PR File Count Check\n\n`;
            commentBody += `**Files changed:** ${fileCount}\n`;
            commentBody += `**CodeRabbit recommended limit:** ${limit}\n\n`;
            
            if (fileCount <= limit) {
              commentBody += `‚úÖ **Status:** Within recommended limit\n\n`;
              commentBody += `This PR is optimally sized for CodeRabbit review.`;
            } else if (hasApprovalLabel) {
              commentBody += `‚ö†Ô∏è  **Status:** Exceeds limit but approved\n\n`;
              commentBody += `This PR has the \`large-pr-approved\` label and will proceed to review.\n\n`;
              commentBody += `**Note:** Large PRs may receive less detailed CodeRabbit feedback.`;
            } else {
              commentBody += `‚ùå **Status:** Exceeds recommended limit\n\n`;
              commentBody += `**Actions required:**\n`;
              commentBody += `1. ‚úÇÔ∏è  Split into smaller PRs (recommended)\n`;
              commentBody += `2. üè∑Ô∏è  Add \`large-pr-approved\` label if justified\n\n`;
              commentBody += `**Why split?** CodeRabbit provides better review quality for PRs under 80 files.`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

  validate:
    name: Validate Salesforce Metadata
    runs-on: ubuntu-latest
    needs: file-count-check
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Cache Salesforce CLI
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/share/sf
            ~/.npm
            ~/.cache/sf
          key: sf-cli-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            sf-cli-${{ runner.os }}-
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Salesforce CLI
        run: npm install -g @salesforce/cli
      
      - name: Install sfdx-hardis
        run: sf plugins install sfdx-hardis
        
      - name: Install sfdx-git-delta
        run: echo "y" | sf plugins install sfdx-git-delta
      
      - name: Authenticate with Salesforce (JWT)
        run: |
          echo "${{ secrets.SERVER_KEY_BASE64 }}" | base64 -d > server.key
          sf org login jwt \
            --client-id "${{ secrets.SF_CONSUMER_KEY }}" \
            --jwt-key-file server.key \
            --username "${{ secrets.SF_USERNAME }}" \
            --instance-url "${{ secrets.SF_INSTANCE_URL }}" \
            --alias validation-org \
            --set-default
          rm server.key
      
      - name: Run PMD static analysis
        run: |
          sf scanner run \
            --target "force-app" \
            --pmdconfig config/pmd-ruleset.xml \
            --format table \
            --severity-threshold 3
      
      - name: Run ESLint
        run: npm run lint
        
      - name: Run Apex tests with coverage
        id: apex_tests
        run: |
          sf apex run test \
            --test-level RunLocalTests \
            --code-coverage \
            --result-format json \
            --wait 20 > test-results.json
          
          # Also show human-readable output
          sf apex run test \
            --test-level RunLocalTests \
            --code-coverage \
            --result-format human \
            --wait 20 || true
      
      - name: Extract coverage data
        if: always()
        id: coverage
        run: |
          if [ -f "test-results.json" ]; then
            COVERAGE=$(jq -r '.summary.orgWideCoverage // "0"' test-results.json)
            FAILURES=$(jq -r '.summary.failing // "0"' test-results.json)
            PASSING=$(jq -r '.summary.passing // "0"' test-results.json)
            
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            echo "failures=$FAILURES" >> $GITHUB_OUTPUT
            echo "passing=$PASSING" >> $GITHUB_OUTPUT
            
            echo "üìä Org-wide coverage: $COVERAGE%"
            echo "‚úÖ Passing tests: $PASSING"
            echo "‚ùå Failed tests: $FAILURES"
          else
            echo "coverage=0" >> $GITHUB_OUTPUT
            echo "failures=0" >> $GITHUB_OUTPUT
            echo "passing=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Post coverage comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = '${{ steps.coverage.outputs.coverage }}';
            const failures = '${{ steps.coverage.outputs.failures }}';
            const passing = '${{ steps.coverage.outputs.passing }}';
            const threshold = 75;
            
            let commentBody = `## üìä Code Coverage Report\n\n`;
            commentBody += `**Org-wide coverage:** ${coverage}%\n`;
            commentBody += `**Required threshold:** ${threshold}%\n`;
            commentBody += `**Passing tests:** ${passing}\n`;
            commentBody += `**Failed tests:** ${failures}\n\n`;
            
            if (parseFloat(coverage) >= threshold && failures === '0') {
              commentBody += `‚úÖ **Status:** All checks passed\n\n`;
              commentBody += `- Coverage meets requirements (${coverage}% >= ${threshold}%)\n`;
              commentBody += `- All tests passing`;
            } else {
              commentBody += `‚ùå **Status:** Quality gates not met\n\n`;
              if (parseFloat(coverage) < threshold) {
                commentBody += `- ‚ö†Ô∏è  Coverage below threshold (${coverage}% < ${threshold}%)\n`;
              }
              if (failures !== '0') {
                commentBody += `- ‚ö†Ô∏è  ${failures} test(s) failing\n`;
              }
              commentBody += `\n**Action required:** Fix failing tests and/or add tests to reach ${threshold}% coverage`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
      
      - name: Check coverage threshold
        run: |
          COVERAGE="${{ steps.coverage.outputs.coverage }}"
          THRESHOLD=75
          
          if [ "$(echo "$COVERAGE < $THRESHOLD" | bc -l 2>/dev/null || echo 1)" -eq 1 ] && [ "$COVERAGE" != "0" ]; then
            echo "‚ùå FAILED: Coverage $COVERAGE% is below threshold $THRESHOLD%"
            exit 1
          else
            echo "‚úÖ PASSED: Coverage $COVERAGE% meets threshold"
          fi
      
      - name: Check test failures
        run: |
          FAILURES="${{ steps.coverage.outputs.failures }}"
          
          if [ "$FAILURES" -gt 0 ]; then
            echo "‚ùå FAILED: $FAILURES test(s) failed"
            if [ -f "test-results.json" ]; then
              jq -r '.tests[] | select(.Outcome == "Fail") | "\(.FullName): \(.Message)"' test-results.json || true
            fi
            exit 1
          else
            echo "‚úÖ PASSED: All tests passing"
          fi
      
      - name: Generate delta package
        run: bash scripts/ci/generate-delta-package.sh origin/${{ github.base_ref }}
      
      - name: Check-only deployment (delta)
        if: hashFiles('changed-sources/package/package.xml') != ''
        run: |
          echo "üöÄ Deploying delta package..."
          
          # Check if package has actual content (not just empty package)
          if grep -q "<members>" changed-sources/package/package.xml; then
            sf project deploy start \
              --manifest changed-sources/package/package.xml \
              --check-only \
              --test-level RunLocalTests \
              --wait 20 \
              --verbose
          else
            echo "‚ÑπÔ∏è  No metadata to deploy (empty package)"
          fi
